<h2 id="git-内部原理">Git 内部原理</h2>

<p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。</p>

<h3 id="底层命令和高层命令">底层命令和高层命令</h3>

<p>由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“高层（porcelain）”命令。</p>

<p>底层命令得以让你窥探 Git 内部的工作机制，也有助于说明 Git 是如何完成工作的，以及它为何如此运作。 多数底层命令并不面向最终用户：它们更适合作为新命令和自定义脚本的组成部分。</p>

<p>当在一个新目录或已有目录执行 <code class="highlighter-rouge">git init</code> 时，Git 会创建一个 <code class="highlighter-rouge">.git</code> 目录。 这个目录包含了几乎所有 Git 存储和操作的对象。 如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。 本章探讨的所有内容，均位于这个目录内。 该目录的结构如下所示：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">ls</span> <span class="nt">-F1</span>
<span class="go">HEAD
config*
description
hooks/
info/
objects/
refs/
</span></code></pre></div></div>

<p>该目录下可能还会包含其他文件，不过对于一个全新的 <code class="highlighter-rouge">git init</code> 版本库，这将是你看到的默认结构。<code class="highlighter-rouge">description</code> 文件仅供 GitWeb 程序使用，我们无需关心。 <code class="highlighter-rouge">config</code> 文件包含项目特有的配置选项。<code class="highlighter-rouge">info</code> 目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。 <code class="highlighter-rouge">hooks</code> 目录包含客户端或服务端的钩子脚本（hook scripts），在 <a href="https://progit.bootcss.com/#_git_hooks">Git 钩子</a> 中这部分话题已被详细探讨过。</p>

<p>剩下的四个条目很重要：<code class="highlighter-rouge">HEAD</code> 文件、（尚待创建的）<code class="highlighter-rouge">index</code> 文件，和 <code class="highlighter-rouge">objects</code> 目录、<code class="highlighter-rouge">refs</code> 目录。 这些条目是 Git 的核心组成部分。 <code class="highlighter-rouge">objects</code> 目录存储所有数据内容；<code class="highlighter-rouge">refs</code> 目录存储指向数据（分支）的提交对象的指针；<code class="highlighter-rouge">HEAD</code> 文件指示目前被检出的分支；<code class="highlighter-rouge">index</code> 文件保存暂存区信息。 我们将详细地逐一检视这四部分，以期理解 Git 是如何运转的。</p>

<h3 id="git-对象">Git 对象</h3>

<p>Git 是一个内容寻址文件系统。 看起来很酷， 但这是什么意思呢？ 这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 可以通过底层命令 <code class="highlighter-rouge">hash-object</code> 来演示上述效果——该命令可将任意数据保存于 <code class="highlighter-rouge">.git</code> 目录，并返回相应的键值。 首先，我们需要初始化一个新的 Git 版本库，并确认 <code class="highlighter-rouge">objects</code> 目录为空：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git init <span class="nb">test</span>
<span class="go">Initialized empty Git repository in /tmp/test/.git/
</span><span class="gp">$</span><span class="w"> </span><span class="nb">cd test</span>
<span class="gp">$</span><span class="w"> </span>find .git/objects
<span class="go">.git/objects
.git/objects/info
.git/objects/pack
</span><span class="gp">$</span><span class="w"> </span>find .git/objects <span class="nt">-type</span> f
</code></pre></div></div>

<p>可以看到 Git 对 <code class="highlighter-rouge">objects</code> 目录进行了初始化，并创建了 <code class="highlighter-rouge">pack</code> 和 <code class="highlighter-rouge">info</code> 子目录，但均为空。 接着，往 Git 数据库存入一些文本：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'test content'</span> | git hash-object <span class="nt">-w</span> <span class="nt">--stdin</span>
<span class="go">d670460b4b4aece5915caf5c68d12f560a9fe3e4
</span></code></pre></div></div>

<p><code class="highlighter-rouge">-w</code> 选项指示 <code class="highlighter-rouge">hash-object</code> 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。 <code class="highlighter-rouge">--stdin</code>选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。 该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。后文会简要讨论该头部信息。 现在我们可以查看 Git 是如何存储数据的：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>find .git/objects <span class="nt">-type</span> f
<span class="go">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</span></code></pre></div></div>

<p>可以在 <code class="highlighter-rouge">objects</code> 目录下看到一个文件。 这就是开始时 Git 存储内容的方式——一个文件对应一条内容，以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p>

<p>可以通过 <code class="highlighter-rouge">cat-file</code> 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 <code class="highlighter-rouge">cat-file</code> 指定 <code class="highlighter-rouge">-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示格式友好的内容：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> d670460b4b4aece5915caf5c68d12f560a9fe3e4
<span class="go">test content
</span></code></pre></div></div>

<p>至此，你已经掌握了如何向 Git 中存入内容，以及如何将它们取出。 我们同样可以将这些操作应用于文件中的内容。 例如，可以对一个文件进行简单的版本控制。 首先，创建一个新文件并将其内容存入数据库：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'version 1'</span> <span class="o">&gt;</span> test.txt
<span class="gp">$</span><span class="w"> </span>git hash-object <span class="nt">-w</span> test.txt
<span class="go">83baae61804e65cc73a7201a7252750c76066a30
</span></code></pre></div></div>

<p>接着，向文件里写入新内容，并再次将其存入数据库：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'version 2'</span> <span class="o">&gt;</span> test.txt
<span class="gp">$</span><span class="w"> </span>git hash-object <span class="nt">-w</span> test.txt
<span class="go">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
</span></code></pre></div></div>

<p>数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>find .git/objects <span class="nt">-type</span> f
<span class="go">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</span></code></pre></div></div>

<p>现在可以把文件内容恢复到第一个版本：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> 83baae61804e65cc73a7201a7252750c76066a30 <span class="o">&gt;</span> test.txt
<span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>test.txt
<span class="go">version 1
</span></code></pre></div></div>

<p>或者第二个版本：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a <span class="o">&gt;</span> test.txt
<span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>test.txt
<span class="go">version 2
</span></code></pre></div></div>

<p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为数据对象（blob object）。 利用 <code class="highlighter-rouge">cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-t</span> 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
<span class="go">blob
</span></code></pre></div></div>

<h4 id="树对象">树对象</h4>

<p>接下来要探讨的对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> master^<span class="o">{</span>tree<span class="o">}</span>
<span class="go">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
</span></code></pre></div></div>

<p><code class="highlighter-rouge">master^{tree}</code> 语法表示 <code class="highlighter-rouge">master</code> 分支上最新的提交所指向的树对象。 请注意，<code class="highlighter-rouge">lib</code> 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
<span class="go">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
</span></code></pre></div></div>

<p>从概念上讲，Git 内部存储的数据有点像这样：</p>

<p><img src="https://progit.bootcss.com/images/data-model-1.png" alt="简化版的 Git 数据模型。" /></p>

<p>Figure 149. 简化版的 Git 数据模型。</p>

<p>你可以轻松创建自己的树对象。 通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。 因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。 可以通过底层命令 <code class="highlighter-rouge">update-index</code> 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。 利用该命令，可以把 test.txt 文件的首个版本人为地加入一个新的暂存区。 必须为上述命令指定 <code class="highlighter-rouge">--add</code> 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）；同样必需的还有 <code class="highlighter-rouge">--cacheinfo</code> 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。 同时，需要指定文件模式、SHA-1 与文件名：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git update-index <span class="nt">--add</span> <span class="nt">--cacheinfo</span> 100644 <span class="se">\</span>
  83baae61804e65cc73a7201a7252750c76066a30 test.txt
</code></pre></div></div>

<p>本例中，我们指定的文件模式为 <code class="highlighter-rouge">100644</code>，表明这是一个普通文件。 其他选择包括：<code class="highlighter-rouge">100755</code>，表示一个可执行文件；<code class="highlighter-rouge">120000</code>，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p>

<p>现在，可以通过 <code class="highlighter-rouge">write-tree</code> 命令将暂存区内容写入一个树对象。 此处无需指定 <code class="highlighter-rouge">-w</code> 选项——如果某个树对象此前并不存在的话，当调用 <code class="highlighter-rouge">write-tree</code> 命令时，它会根据当前暂存区状态自动创建一个新的树对象：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git write-tree
<span class="go">d8329fc1cc938780ffdd9f94e0d364e0ea74f579
</span><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<span class="go">100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
</span></code></pre></div></div>

<p>不妨验证一下它确实是一个树对象：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-t</span> d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<span class="go">tree
</span></code></pre></div></div>

<p>接着我们来创建一个新的树对象，它包括 test.txt 文件的第二个版本，以及一个新的文件：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'new file'</span> <span class="o">&gt;</span> new.txt
<span class="gp">$</span><span class="w"> </span>git update-index <span class="nt">--cacheinfo</span> 100644 <span class="se">\</span>
  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
<span class="gp">$</span><span class="w"> </span>git update-index test.txt
<span class="gp">$</span><span class="w"> </span>git update-index <span class="nt">--add</span> new.txt
</code></pre></div></div>

<p>暂存区现在包含了 test.txt 文件的新版本，和一个新文件：new.txt。 记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git write-tree
<span class="go">0155eb4229851634a0f03eb265b69f5a2d56f341
</span><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> 0155eb4229851634a0f03eb265b69f5a2d56f341
<span class="go">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
</span></code></pre></div></div>

<p>我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（<code class="highlighter-rouge">1f7a7a</code>）是先前值的“第二版”。 只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。 通过调用 <code class="highlighter-rouge">read-tree</code> 命令，可以把树对象读入暂存区。 本例中，可以通过对 <code class="highlighter-rouge">read-tree</code> 指定 <code class="highlighter-rouge">--prefix</code> 选项，将一个已有的树对象作为子树读入暂存区：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git read-tree <span class="nt">--prefix</span><span class="o">=</span>bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
<span class="gp">$</span><span class="w"> </span>git write-tree
<span class="go">3c4e9cd789d88d8d89c1073707c3585e41b0e614
</span><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> 3c4e9cd789d88d8d89c1073707c3585e41b0e614
<span class="go">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
</span></code></pre></div></div>

<p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code class="highlighter-rouge">bak</code> 的子目录，该子目录包含 test.txt 文件的第一个版本。 可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p>

<p><img src="https://progit.bootcss.com/images/data-model-2.png" alt="当前 Git 的数据内容结构。" /></p>

<p>Figure 150. 当前 Git 的数据内容结构。</p>

<h4 id="提交对象">提交对象</h4>

<p>现在有三个树对象，分别代表了我们想要跟踪的不同项目快照。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p>

<p>可以通过调用 <code class="highlighter-rouge">commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。 我们从之前创建的第一个树对象开始：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'first commit'</span> | git commit-tree d8329f
<span class="go">fdf4fc3344e67ab068f836878b6c4951e3b15f3d
</span></code></pre></div></div>

<p>现在可以通过 <code class="highlighter-rouge">cat-file</code> 命令查看这个新提交对象：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> fdf4fc3
<span class="go">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
</span><span class="gp">author Scott Chacon &lt;schacon@gmail.com&gt;</span><span class="w"> </span>1243040974 <span class="nt">-0700</span>
<span class="gp">committer Scott Chacon &lt;schacon@gmail.com&gt;</span><span class="w"> </span>1243040974 <span class="nt">-0700</span>
<span class="go">
first commit
</span></code></pre></div></div>

<p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的 <code class="highlighter-rouge">user.name</code> 和 <code class="highlighter-rouge">user.email</code> 配置来设定，外加一个时间戳）；留空一行，最后是提交注释。</p>

<p>接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'second commit'</span> | git commit-tree 0155eb <span class="nt">-p</span> fdf4fc3
<span class="go">cac0cab538b970a37ea1e769cbbde608743bc96d
</span><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'third commit'</span>  | git commit-tree 3c4e9c <span class="nt">-p</span> cac0cab
<span class="go">1a410efbd13591db07496601ebc7a059dd55cfe9
</span></code></pre></div></div>

<p>这三个提交对象分别指向之前创建的三个树对象快照中的一个。 现在，如果对最后一个提交的 SHA-1 值运行 <code class="highlighter-rouge">git log</code> 命令，会出乎意料的发现，你已有一个货真价实的、可由 <code class="highlighter-rouge">git log</code> 查看的 Git 提交历史了：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git log <span class="nt">--stat</span> 1a410e
<span class="go">commit 1a410efbd13591db07496601ebc7a059dd55cfe9
</span><span class="gp">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><span class="w">
</span><span class="go">Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
</span><span class="gp">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><span class="w">
</span><span class="go">Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
</span><span class="gp">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><span class="w">
</span><span class="go">Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
</span></code></pre></div></div>

<p>太神奇了： 就在刚才，你没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。 这就是每次我们运行 <code class="highlighter-rouge">git add</code> 和 <code class="highlighter-rouge">git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 <code class="highlighter-rouge">.git/objects</code> 目录下。 下面列出了目前示例目录内的所有对象，辅以各自所保存内容的注释：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>find .git/objects <span class="nt">-type</span> f
<span class="gp">.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 #</span><span class="w"> </span>tree 2
<span class="gp">.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 #</span><span class="w"> </span>commit 3
<span class="gp">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a #</span><span class="w"> </span>test.txt v2
<span class="gp">.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 #</span><span class="w"> </span>tree 3
<span class="gp">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 #</span><span class="w"> </span>test.txt v1
<span class="gp">.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d #</span><span class="w"> </span>commit 2
<span class="gp">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 #</span><span class="w"> </span><span class="s1">'test content'</span>
<span class="gp">.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 #</span><span class="w"> </span>tree 1
<span class="gp">.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 #</span><span class="w"> </span>new.txt
<span class="gp">.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d #</span><span class="w"> </span>commit 1
</code></pre></div></div>

<p>如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p>

<p><img src="https://progit.bootcss.com/images/data-model-3.png" alt="你的 Git 目录下的所有对象。" /></p>

<p>Figure 151. 你的 Git 目录下的所有对象。</p>

<h4 id="对象存储">对象存储</h4>

<p>前文曾提及，在存储内容时，会有个头部信息一并被保存。 让我们略花些时间来看看 Git 是如何存储其对象的。 通过在 Ruby 脚本语言中交互式地演示，你将看到一个数据对象——本例中是字符串“what is up, doc?”——是如何被存储的。</p>

<p>可以通过 <code class="highlighter-rouge">irb</code> 命令启动 Ruby 的交互模式：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>irb
<span class="gp">&gt;</span><span class="o">&gt;</span> content <span class="o">=</span> <span class="s2">"what is up, doc?"</span>
<span class="gp">=&gt;</span><span class="w"> </span><span class="s2">"what is up, doc?"</span>
</code></pre></div></div>

<p>Git 以对象类型作为开头来构造一个头部信息，本例中是一个“blob”字符串。 接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="o">&gt;</span> header <span class="o">=</span> <span class="s2">"blob #{content.length}</span><span class="se">\0</span><span class="s2">"</span>
<span class="gp">=&gt;</span><span class="w"> </span><span class="s2">"blob 16</span><span class="se">\u</span><span class="s2">0000"</span>
</code></pre></div></div>

<p>Git 会将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和。 在 Ruby 中可以这样计算 SHA-1 值——先通过 <code class="highlighter-rouge">require</code> 命令导入 SHA-1 digest 库，然后对目标字符串调用 <code class="highlighter-rouge">Digest::SHA1.hexdigest()</code>：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="o">&gt;</span> store <span class="o">=</span> header + content
<span class="gp">=&gt;</span><span class="w"> </span><span class="s2">"blob 16</span><span class="se">\u</span><span class="s2">0000what is up, doc?"</span>
<span class="gp">&gt;</span><span class="o">&gt;</span> require <span class="s1">'digest/sha1'</span>
<span class="gp">=&gt;</span><span class="w"> </span><span class="nb">true</span>
<span class="gp">&gt;</span><span class="o">&gt;</span> sha1 <span class="o">=</span> Digest::SHA1.hexdigest<span class="o">(</span>store<span class="o">)</span>
<span class="gp">=&gt;</span><span class="w"> </span><span class="s2">"bd9dbf5aae1a3862dd1526723246b20206e5fc37"</span>
</code></pre></div></div>

<p>Git 会通过 zlib 压缩这条新内容。在 Ruby 中可以借助 zlib 库做到这一点。 先导入相应的库，然后对目标内容调用 <code class="highlighter-rouge">Zlib::Deflate.deflate()</code>：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="o">&gt;</span> require <span class="s1">'zlib'</span>
<span class="gp">=&gt;</span><span class="w"> </span><span class="nb">true</span>
<span class="gp">&gt;</span><span class="o">&gt;</span> zlib_content <span class="o">=</span> Zlib::Deflate.deflate<span class="o">(</span>store<span class="o">)</span>
<span class="gp">=&gt;</span><span class="w"> </span><span class="s2">"x</span><span class="se">\x</span><span class="s2">9CK</span><span class="se">\x</span><span class="s2">CA</span><span class="se">\x</span><span class="s2">C9OR04c(</span><span class="se">\x</span><span class="s2">CFH,Q</span><span class="se">\x</span><span class="s2">C8,V(-</span><span class="se">\x</span><span class="s2">D0QH</span><span class="se">\x</span><span class="s2">C9O</span><span class="se">\x</span><span class="s2">B6</span><span class="se">\a\x</span><span class="s2">00_</span><span class="se">\x</span><span class="s2">1C</span><span class="se">\a\x</span><span class="s2">9D"</span>
</code></pre></div></div>

<p>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。 要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。 如果该子目录不存在，可以通过 Ruby 中的 <code class="highlighter-rouge">FileUtils.mkdir_p()</code> 函数来创建它。 接着，通过 <code class="highlighter-rouge">File.open()</code> 打开这个文件。最后，对上一步中得到的文件句柄调用 <code class="highlighter-rouge">write()</code> 函数，以向目标文件写入之前那条 zlib 压缩过的内容：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="o">&gt;</span> path <span class="o">=</span> <span class="s1">'.git/objects/'</span> + sha1[0,2] + <span class="s1">'/'</span> + sha1[2,38]
<span class="gp">=&gt;</span><span class="w"> </span><span class="s2">".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"</span>
<span class="gp">&gt;</span><span class="o">&gt;</span> require <span class="s1">'fileutils'</span>
<span class="gp">=&gt;</span><span class="w"> </span><span class="nb">true</span>
<span class="gp">&gt;</span><span class="o">&gt;</span> FileUtils.mkdir_p<span class="o">(</span>File.dirname<span class="o">(</span>path<span class="o">))</span>
<span class="gp">=&gt;</span><span class="w"> </span><span class="s2">".git/objects/bd"</span>
<span class="gp">&gt;</span><span class="o">&gt;</span> File.open<span class="o">(</span>path, <span class="s1">'w'</span><span class="o">)</span> <span class="o">{</span> |f| f.write zlib_content <span class="o">}</span>
<span class="gp">=&gt;</span><span class="w"> </span>32
</code></pre></div></div>

<p>就是这样——你已创建了一个有效的 Git 数据对象。 所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p>

<h3 id="git-引用">Git 引用</h3>

<p>我们可以借助类似于 <code class="highlighter-rouge">git log 1a410e</code> 这样的命令来浏览完整的提交历史，但为了能遍历那段历史从而找到所有相关对象，你仍须记住 <code class="highlighter-rouge">1a410e</code> 是最后一个提交。 我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p>

<p>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 <code class="highlighter-rouge">.git/refs</code> 目录下找到这类含有 SHA-1 值的文件。 在目前的项目中，这个目录没有包含任何文件，但它包含了一个简单的目录结构：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>find .git/refs
<span class="go">.git/refs
.git/refs/heads
.git/refs/tags
</span><span class="gp">$</span><span class="w"> </span>find .git/refs <span class="nt">-type</span> f
</code></pre></div></div>

<p>若要创建一个新引用来帮助记忆最新提交所在的位置，从技术上讲我们只需简单地做如下操作：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"1a410efbd13591db07496601ebc7a059dd55cfe9"</span> <span class="o">&gt;</span> .git/refs/heads/master
</code></pre></div></div>

<p>现在，你就可以在 Git 命令中使用这个刚创建的新引用来代替 SHA-1 值了：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git log <span class="nt">--pretty</span><span class="o">=</span>oneline  master
<span class="go">1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</span></code></pre></div></div>

<p>我们不提倡直接编辑引用文件。 如果想更新某个引用，Git 提供了一个更加安全的命令 <code class="highlighter-rouge">update-ref</code> 来完成此事：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
</code></pre></div></div>

<p>这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。 若想在第二个提交上创建一个分支，可以这么做：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git update-ref refs/heads/test cac0ca
</code></pre></div></div>

<p>这个分支将只包含从第二个提交开始往前追溯的记录：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git log <span class="nt">--pretty</span><span class="o">=</span>oneline <span class="nb">test</span>
<span class="go">cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</span></code></pre></div></div>

<p>至此，我们的 Git 数据库从概念上看起来像这样：</p>

<p><img src="https://progit.bootcss.com/images/data-model-4.png" alt="包含分支引用的 Git 目录对象。" /></p>

<p>Figure 152. 包含分支引用的 Git 目录对象。</p>

<p>当运行类似于 <code class="highlighter-rouge">git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code class="highlighter-rouge">update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</p>

<h4 id="head-引用">HEAD 引用</h4>

<p>现在的问题是，当你执行 <code class="highlighter-rouge">git branch (branchname)</code> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p>

<p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针。 如果查看 HEAD 文件的内容，一般而言我们看到的类似这样：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> .git/HEAD
<span class="go">ref: refs/heads/master
</span></code></pre></div></div>

<p>如果执行 <code class="highlighter-rouge">git checkout test</code>，Git 会像这样更新 HEAD 文件：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> .git/HEAD
<span class="go">ref: refs/heads/test
</span></code></pre></div></div>

<p>当我们执行 <code class="highlighter-rouge">git commit</code> 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</p>

<p>你也可以手动编辑该文件，然而同样存在一个更安全的命令来完成此事：<code class="highlighter-rouge">symbolic-ref</code>。 可以借助此命令来查看 HEAD 引用对应的值：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git symbolic-ref HEAD
<span class="go">refs/heads/master
</span></code></pre></div></div>

<p>同样可以设置 HEAD 引用的值：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git symbolic-ref HEAD refs/heads/test
<span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> .git/HEAD
<span class="go">ref: refs/heads/test
</span></code></pre></div></div>

<p>不能把符号引用设置为一个不符合引用格式的值：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git symbolic-ref HEAD <span class="nb">test</span>
<span class="go">fatal: Refusing to point HEAD outside of refs/
</span></code></pre></div></div>

<h4 id="标签引用">标签引用</h4>

<p>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。 标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p>

<p>正如 <a href="https://progit.bootcss.com/#_git_basics_chapter">Git 基础</a> 中所讨论的那样，存在两种类型的标签：附注标签和轻量标签。 可以像这样创建一个轻量标签：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
</code></pre></div></div>

<p>这就是轻量标签的全部内容——一个固定的引用。 然而，一个附注标签则更复杂一些。 若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。 可以通过创建一个附注标签来验证这个过程（<code class="highlighter-rouge">-a</code> 选项指定了要创建的是一个附注标签）：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git tag <span class="nt">-a</span> v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 <span class="nt">-m</span> <span class="s1">'test tag'</span>
</code></pre></div></div>

<p>下面是上述过程所建标签对象的 SHA-1 值：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> .git/refs/tags/v1.1
<span class="go">9585191f37f7b0fb9444f35a9bf50de191beadc2
</span></code></pre></div></div>

<p>现在对该 SHA-1 值运行 <code class="highlighter-rouge">cat-file</code> 命令：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> 9585191f37f7b0fb9444f35a9bf50de191beadc2
<span class="go">object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
</span><span class="gp">tagger Scott Chacon &lt;schacon@gmail.com&gt;</span><span class="w"> </span>Sat May 23 16:48:58 2009 <span class="nt">-0700</span>
<span class="go">
test tag
</span></code></pre></div></div>

<p>我们注意到，object 条目指向我们打了标签的那个提交对象的 SHA-1 值。 另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。 例如，在 Git 源码中，项目维护者将他们的 GPG 公钥添加为一个数据对象，然后对这个对象打了一个标签。 可以克隆一个 Git 版本库，然后通过执行下面的命令来在这个版本库中查看上述公钥：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file blob junio-gpg-pub
</code></pre></div></div>

<p>Linux 内核版本库同样有一个不指向提交对象的标签对象——首个被创建的标签对象所指向的是最初被引入版本库的那份内核源码所对应的树对象。</p>

<h4 id="远程引用">远程引用</h4>

<p>我们将看到的第三种引用类型是远程引用（remote reference）。 如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 <code class="highlighter-rouge">refs/remotes</code> 目录下。 例如，你可以添加一个叫做 <code class="highlighter-rouge">origin</code> 的远程版本库，然后把 <code class="highlighter-rouge">master</code> 分支推送上去：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git remote add origin git@github.com:schacon/simplegit-progit.git
<span class="gp">$</span><span class="w"> </span>git push origin master
<span class="go">Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
</span><span class="gp">  a11bef0..ca82a6d  master -&gt;</span><span class="w"> </span>master
</code></pre></div></div>

<p>此时，如果查看 <code class="highlighter-rouge">refs/remotes/origin/master</code> 文件，可以发现 <code class="highlighter-rouge">origin</code> 远程版本库的 <code class="highlighter-rouge">master</code> 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 <code class="highlighter-rouge">master</code> 分支所对应的 SHA-1 值：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> .git/refs/remotes/origin/master
<span class="go">ca82a6dff817ec66f44342007202690a93763949
</span></code></pre></div></div>

<p>远程引用和分支（位于 <code class="highlighter-rouge">refs/heads</code> 目录下的引用）之间最主要的区别在于，远程引用是只读的。 虽然可以 <code class="highlighter-rouge">git checkout</code> 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 <code class="highlighter-rouge">commit</code> 命令来更新远程引用。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p>

<h3 id="包文件">包文件</h3>

<p>让我们重新回到示例 Git 版本库的对象数据库。 目前为止，可以看到有 11 个对象——4 个数据对象、3 个树对象、3 个提交对象和 1 个标签对象：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>find .git/objects <span class="nt">-type</span> f
<span class="gp">.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 #</span><span class="w"> </span>tree 2
<span class="gp">.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 #</span><span class="w"> </span>commit 3
<span class="gp">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a #</span><span class="w"> </span>test.txt v2
<span class="gp">.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 #</span><span class="w"> </span>tree 3
<span class="gp">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 #</span><span class="w"> </span>test.txt v1
<span class="gp">.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 #</span><span class="w"> </span>tag
<span class="gp">.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d #</span><span class="w"> </span>commit 2
<span class="gp">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 #</span><span class="w"> </span><span class="s1">'test content'</span>
<span class="gp">.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 #</span><span class="w"> </span>tree 1
<span class="gp">.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 #</span><span class="w"> </span>new.txt
<span class="gp">.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d #</span><span class="w"> </span>commit 1
</code></pre></div></div>

<p>Git 使用 zlib 压缩这些文件的内容，而且我们并没有存储太多东西，所以上文中的文件一共只占用了 925 字节。 接下来，我们会指引你添加一些大文件到版本库中，以此展示 Git 的一个很有趣的功能。 为了便于展示，我们要把之前在 Grit 库中用到过的 <code class="highlighter-rouge">repo.rb</code> 文件添加进来——这是一个大小约为 22K 的源代码文件：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb <span class="o">&gt;</span> repo.rb
<span class="gp">$</span><span class="w"> </span>git add repo.rb
<span class="gp">$</span><span class="w"> </span>git commit <span class="nt">-m</span> <span class="s1">'added repo.rb'</span>
<span class="go">[master 484a592] added repo.rb
 3 files changed, 709 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)
</span></code></pre></div></div>

<p>如果你查看生成的树对象，可以看到 repo.rb 文件对应的数据对象的 SHA-1 值：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> master^<span class="o">{</span>tree<span class="o">}</span>
<span class="go">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
</span></code></pre></div></div>

<p>接下来你可以使用 <code class="highlighter-rouge">git cat-file</code> 命令查看这个对象有多大：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-s</span> 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
<span class="go">22044
</span></code></pre></div></div>

<p>现在，稍微修改这个文件，然后看看会发生什么：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'# testing'</span> <span class="o">&gt;&gt;</span> repo.rb
<span class="gp">$</span><span class="w"> </span>git commit <span class="nt">-am</span> <span class="s1">'modified repo a bit'</span>
<span class="go">[master 2431da6] modified repo.rb a bit
 1 file changed, 1 insertion(+)
</span></code></pre></div></div>

<p>查看这个提交生成的树对象，你会看到一些有趣的东西：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-p</span> master^<span class="o">{</span>tree<span class="o">}</span>
<span class="go">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
</span></code></pre></div></div>

<p>repo.rb 对应一个与之前完全不同的数据对象，这意味着，虽然你只是在一个 400 行的文件后面加入一行新内容，Git 也会用一个全新的对象来存储新的文件内容：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git cat-file <span class="nt">-s</span> b042a60ef7dff760008df33cee372b945b6e884e
<span class="go">22054
</span></code></pre></div></div>

<p>你的磁盘上现在有两个几乎完全相同、大小均为 22K 的对象。 如果 Git 只完整保存其中一个，再保存另一个对象与之前版本的差异内容，岂不更好？</p>

<p>事实上 Git 可以那样做。 Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 <code class="highlighter-rouge">git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。 要看到打包过程，你可以手动执行 <code class="highlighter-rouge">git gc</code> 命令让 Git 对对象进行打包：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git gc
<span class="go">Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)
</span></code></pre></div></div>

<p>这个时候再查看 objects 目录，你会发现大部分的对象都不见了，与此同时出现了一对新文件：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>find .git/objects <span class="nt">-type</span> f
<span class="go">.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack
</span></code></pre></div></div>

<p>仍保留着的几个对象是未被任何提交记录引用的数据对象——在此例中是你之前创建的“what is up, doc?”和“test content”这两个示例数据对象。 因为你从没将它们添加至任何提交记录中，所以 Git 认为它们是悬空（dangling）的，不会将它们打包进新生成的包文件中。</p>

<p>剩下的文件是新创建的包文件和一个索引。 包文件包含了刚才从文件系统中移除的所有对象的内容。 索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。 有意思的是运行 <code class="highlighter-rouge">gc</code> 命令前磁盘上的对象大小约为 22K，而这个新生成的包文件大小仅有 7K。 通过打包对象减少了 ⅔ 的磁盘占用空间。</p>

<p>Git 是如何做到这点的？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。 你可以查看包文件，观察它是如何节省空间的。 <code class="highlighter-rouge">git verify-pack</code> 这个底层命令可以让你查看已打包的内容：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git verify-pack <span class="nt">-v</span> .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
<span class="go">2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \
  b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok
</span></code></pre></div></div>

<p>此处，<code class="highlighter-rouge">033b4</code> 这个数据对象（即 repo.rb 文件的第一个版本，如果你还记得的话）引用了数据对象 <code class="highlighter-rouge">b042a</code>，即该文件的第二个版本。 命令输出内容的第三列显示的是各个对象在包文件中的大小，可以看到 <code class="highlighter-rouge">b042a</code> 占用了 22K 空间，而 <code class="highlighter-rouge">033b4</code> 仅占用 9 字节。 同样有趣的地方在于，第二个版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。最妙之处是你可以随时重新打包。</p>

<p>Git 时常会自动对仓库进行重新打包以节省空间。当然你也可以随时手动执行 <code class="highlighter-rouge">git gc</code> 命令来这么做。</p>

<h3 id="引用规格">引用规格</h3>

<p>纵观全书，我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。 假设你添加了这样一个远程版本库：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git remote add origin https://github.com/schacon/simplegit-progit
</code></pre></div></div>

<p>上述命令会在你的 <code class="highlighter-rouge">.git/config</code> 文件中添加一个小节，并在其中指定远程版本库的名称（<code class="highlighter-rouge">origin</code>）、URL 和一个用于获取操作的引用规格（refspec）：</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[remote "origin"]</span>
	<span class="py">url</span> <span class="p">=</span> <span class="s">https://github.com/schacon/simplegit-progit</span>
	<span class="py">fetch</span> <span class="p">=</span> <span class="s">+refs/heads/*:refs/remotes/origin/*</span>
</code></pre></div></div>

<p>引用规格的格式由一个可选的 <code class="highlighter-rouge">+</code> 号和紧随其后的 <code class="highlighter-rouge">&lt;src&gt;:&lt;dst&gt;</code> 组成，其中 <code class="highlighter-rouge">&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用；<code class="highlighter-rouge">&lt;dst&gt;</code> 是那些远程引用在本地所对应的位置。 <code class="highlighter-rouge">+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p>

<p>默认情况下，引用规格由 <code class="highlighter-rouge">git remote add</code> 命令自动生成， Git 获取服务器中 <code class="highlighter-rouge">refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code class="highlighter-rouge">refs/remotes/origin/</code> 中。 所以，如果服务器上有一个 <code class="highlighter-rouge">master</code> 分支，我们可以在本地通过下面这种方式来访问该分支上的提交记录：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git log origin/master
<span class="gp">$</span><span class="w"> </span>git log remotes/origin/master
<span class="gp">$</span><span class="w"> </span>git log refs/remotes/origin/master
</code></pre></div></div>

<p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 <code class="highlighter-rouge">refs/remotes/origin/master</code>。</p>

<p>如果想让 Git 每次只拉取远程的 <code class="highlighter-rouge">master</code> 分支，而不是所有分支，可以把（引用规格的）获取那一行修改为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch = +refs/heads/master:refs/remotes/origin/master
</code></pre></div></div>

<p>这仅是针对该远程版本库的 <code class="highlighter-rouge">git fetch</code> 操作的默认引用规格。 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规格。 若要将远程的 <code class="highlighter-rouge">master</code> 分支拉到本地的 <code class="highlighter-rouge">origin/mymaster</code> 分支，可以运行：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git fetch origin master:refs/remotes/origin/mymaster
</code></pre></div></div>

<p>你也可以指定多个引用规格。 在命令行中，你可以按照如下的方式拉取多个分支：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git fetch origin master:refs/remotes/origin/mymaster <span class="se">\</span>
	 topic:refs/remotes/origin/topic
<span class="go">From git@github.com:schacon/simplegit
</span><span class="gp"> ! [rejected]        master     -&gt;</span><span class="w"> </span>origin/mymaster  <span class="o">(</span>non fast forward<span class="o">)</span>
<span class="gp"> * [new branch]      topic      -&gt;</span><span class="w"> </span>origin/topic
</code></pre></div></div>

<p>在这个例子中，对 <code class="highlighter-rouge">master</code> 分支的拉取操作被拒绝，因为它不是一个可以快进的引用。 我们可以通过在引用规格之前指定 <code class="highlighter-rouge">+</code> 号来覆盖该规则。</p>

<p>你也可以在配置文件中指定多个用于获取操作的引用规格。 如果想在每次获取时都包括 <code class="highlighter-rouge">master</code> 和 <code class="highlighter-rouge">experiment</code> 分支，添加如下两行：</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[remote "origin"]</span>
	<span class="py">url</span> <span class="p">=</span> <span class="s">https://github.com/schacon/simplegit-progit</span>
	<span class="py">fetch</span> <span class="p">=</span> <span class="s">+refs/heads/master:refs/remotes/origin/master</span>
	<span class="py">fetch</span> <span class="p">=</span> <span class="s">+refs/heads/experiment:refs/remotes/origin/experiment</span>
</code></pre></div></div>

<p>我们不能在模式中使用部分通配符，所以像下面这样的引用规格是不合法的：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch = +refs/heads/qa*:refs/remotes/origin/qa*
</code></pre></div></div>

<p>但我们可以使用命名空间（或目录）来达到类似目的。 假设你有一个 QA 团队，他们推送了一系列分支，同时你只想要获取 <code class="highlighter-rouge">master</code> 和 QA 团队的所有分支而不关心其他任何分支，那么可以使用如下配置：</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[remote "origin"]</span>
	<span class="py">url</span> <span class="p">=</span> <span class="s">https://github.com/schacon/simplegit-progit</span>
	<span class="py">fetch</span> <span class="p">=</span> <span class="s">+refs/heads/master:refs/remotes/origin/master</span>
	<span class="py">fetch</span> <span class="p">=</span> <span class="s">+refs/heads/qa/*:refs/remotes/origin/qa/*</span>
</code></pre></div></div>

<p>如果项目的工作流很复杂，有 QA 团队推送分支、开发人员推送分支、集成团队推送并且在远程分支上展开协作，你就可以像这样（在本地）为这些分支创建各自的命名空间，非常方便</p>

<h4 id="引用规格推送">引用规格推送</h4>

<p>像上面这样从远程版本库获取已在命名空间中的引用当然很棒，但 QA 团队最初应该如何将他们的分支放入远程的 <code class="highlighter-rouge">qa/</code> 命名空间呢？ 我们可以通过引用规格推送来完成这个任务。</p>

<p>如果 QA 团队想把他们的 <code class="highlighter-rouge">master</code> 分支推送到远程服务器的 <code class="highlighter-rouge">qa/master</code> 分支上，可以运行：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git push origin master:refs/heads/qa/master
</code></pre></div></div>

<p>如果他们希望 Git 每次运行 <code class="highlighter-rouge">git push origin</code> 时都像上面这样推送，可以在他们的配置文件中添加一条 <code class="highlighter-rouge">push</code> 值：</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[remote "origin"]</span>
	<span class="py">url</span> <span class="p">=</span> <span class="s">https://github.com/schacon/simplegit-progit</span>
	<span class="py">fetch</span> <span class="p">=</span> <span class="s">+refs/heads/*:refs/remotes/origin/*</span>
	<span class="py">push</span> <span class="p">=</span> <span class="s">refs/heads/master:refs/heads/qa/master</span>
</code></pre></div></div>

<p>正如刚才所指出的，这会让 <code class="highlighter-rouge">git push origin</code> 默认把本地 <code class="highlighter-rouge">master</code> 分支推送到远程 <code class="highlighter-rouge">qa/master</code> 分支。</p>

<h4 id="删除引用">删除引用</h4>

<p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>git push origin :topic
</code></pre></div></div>

<p>因为引用规格（的格式）是 <code class="highlighter-rouge">&lt;src&gt;:&lt;dst&gt;</code>，所以上述命令把 <code class="highlighter-rouge">&lt;src&gt;</code> 留空，意味着把远程版本库的 <code class="highlighter-rouge">topic</code>分支定义为空值，也就是删除它。</p>

<h3 id="传输协议">传输协议</h3>

<p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p>

